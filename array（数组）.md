这是基于C++ Primer的 3.5 & 3.6的笔记

# 数组

数组是一种类似于标准库类型vector的数据结构，但是在性能和灵活性的权衡上与vector 不同。
与vector 相似的地方是，数组也是存放类型相同的对象容器，这些对象本身没有名字，需要通过器所在位置访问。与vector 不同的地方是， 数组的大小确定不变，不能随意向数组中增加元素。 因为数组的大小固定，因此对某些特殊的应用来说程序运行的性能较好，但是相应地失去了一些灵活性。

# 定义和初始化内置数组

数组是一种复合类型。 数组声明形如 a[d], 其中a 是数组的名字，d是数组的维度。 唯独说明了数组的元素个数， 因此必须大于0. 数组中元素的个数也属于数组类型的一部分，编译时维度应该是已知的，即必须是常量表达式。

![](https://github.com/linbearababy/primer-c-/blob/master/屏幕快照%202019-05-18%2020.35.57.png)

![](https://github.com/linbearababy/primer-c-/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-18%2020.36.06.png)

理解复杂的数组声明

和vector一样,数组能存放大多数类型的对象。例如可以定义一个存放指针的数组。又因为数组本身流就是对象，所以允许定义数组的指针即数组的引用。在这几种情况下，定义存放指针的数组比较简单和直接，但是定义数组的指针或数组的引用就稍微复杂了： 

    int *ptrs[10];                             //ptrs 是含有10个整型指针的数组
    int &refs[10] = /*?*/;               //错误：不存在引用的数组
    int (*parray)[10] = &arr;             //parray 指向一个含有10个整数型的数组
    int (&arrRef)[10] = arr;              //arrRef引用一个含有10个整数的数组

默认情况下，类型修饰符从右向左依此绑定。对于ptrs来说，从右向左理解比较简单：首先，我们定义一个大小为10的数组，他的名字是ptrs，然后知道数组中存放的是指向int 的指针。

但是对于parray，从右向左理解就不太合理了。因为数组的维度是紧跟着被声明的名字的，所以就数组而言，由内向外阅读要比从右向左好多了。理解：首先，是圆括号的部分， *parray意味着parray是个指针，可下来观察右边，可知parray是个指向大小为10的数组指针，左后观察左边，知道数组中的元素是int.最终， parray是一个指针，他指向一个int数组，数组中包含10个元素。 同理， （&arrRef)表示arrRef是一个引用，他的引用对象是一个大小为10的数组，数组中元素类型是int.

对修饰符的数量并没有特殊限制：

int *(&arry)[10] = ptrs;         //arry是一个数组的引用，该数组含有10个指针

arry是一个引用， 观察右边，arry引用对象是一个大小为10的数组，最后看左边，数组的元素类型是指向int的指针。这样，arry就是一个含有10个int类型指针的数组。

# 访问数组元素

和标准库（vector & string一样，数组的元素也能使用范围for 语句或下标运算符来访问。数组的索引也是从0开始

使用数组下标时，通常将其定义为size_t 类型。size_t类型是一种机器相关的无符号类型，他被设计的足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型， 这个文件是c标准库stddef.h 头文件的c++ 语言版本。

数组除了大小固定这一特点，其他用法和vector 一样：
  
    //以10分为一个分数段统计成绩的数量
    unsigned scores[11] ={};        //11个分数段初始化为0
    unsigned grade;
    while (cin>>grade) {
      if (grade <= 100){
        ++scores[grade/10];          //将当前分数段的计数+1
        }
       }

遍历数组元素，用for loop：

    for（auto i : scores) {     
        cout <<i<<" ";}
    cout <<endl;
    
检查下标的值： 

与vector & string一样， 检查数组的下标是否在合理范围之内（下标大于等于0，而且小于数组的大小）

# 指针和数组

在c++ 中数组和指针有着非常紧密的联系。使用数组的时候，编译器会把它转化成数组。

通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可作用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素。因此和其他对象一样，对数组的元素使用取地址符就能得到该元素的指针：

    string nums[]= {"one","two","three"};      //数组的元素是string对象
    string *p = &nums[0];                      //p 指向nums 的第一个元素

数组还有一个特性： 在很多用到数组名字的地方，编译器会自动地将其替换为一个指向首元素的的指针：

       string *p2 = nums;          //等价于 p= &nums[0]

综上，数组的操作实际上是指针的操作。意味着： 当使用数组作为一个auto 变量的初始值时，推断得到的类型是指针而非数组： 

    int ia[] = {0,1,2,3,4,5,6,7,8,9};          //ia是一个含有10个整数的数组
    auto ia2(ia);                              //ia2是一个整型指针，指向ia的第一个元素
    ia2 =42;                                   //错误： ia2 是一个指针， 不能用int 值给指针赋值

尽管ia是由10个整数构成的数组，但当使用ia作为初始值时，编译器实际执行的初始值化过程类似于下面的形式：

    auto ia2(&ia[0]);       //显然ia2 的类型是*int

必须指出的是，当使用decltype关键字时上述转换不会发生，decltype（ia)返回的类型是由10个整数构成的数组：

        // ia3是一个含有10个整数的数组
        decltype(ia) ia3= {0,1,2,3,4,5,6,7,8,9};           
        ia3 = p;                   //false: 不能使用整型指针给数组赋值
        ia[4] = i;                  // 正确：把i 的值赋给ia3的一个元素

# 指针也是迭代器 

vector and string 的迭代器支持的运算，数组的指针全都支持。eg:

        int arr[] = {0,1,2,3,4,5,6,7,8,9};        
        int *p = arr;              //p指向arr的第一个元素
        ++ p;                         // p 指向arr[1];

使用指针也能遍历数组中的元素。当然这样做的前提是先得获取到指向数组第一个元素的指针和指向数组尾元素的下一位置的指针。之前说过，通过数组名字或者数组中首元素的地址我们都能得到指向首元素的指针：不过获取尾后指针就要用到数组的另外一个性质了。我们可以设法获取数组尾元素之后的那个并不存在的元素的地址：

    int *e = &arr[10];       // 指向arr尾元素的下一位置的指针；
这里使用了下标运算符索引了一个不存在的元素，arr 有10个元素，尾元素所在的位置的索引是9，接下来那个不存在的元素唯一的用处就是提供其地址用于初始化e. 就像尾后迭代器一样，尾后指针也不指向具体元素。因此不能对尾后指针执行解引或递增操作。

    //循环arr中每个元素
    for (int *b = arr; b!= e; ++b){       
    cout << *b <<edl;}
    
# 标准库函数 begin & end
尽管能计算得到尾后指针，但这种方法容易出错出错。为了指针的使用跟简单，安全，c++新标准库引入了两个名为begin & end 的函数。这两个函数于容器中同名函数功能类似，不过数组不是类类型，因此这两个同名函数不是成员函数，这两个函数定义在iterator头文件。正确的使用形式是将数组作为他们的参数：

    int ia[] = {0,1,2,3,4,5,6,7,8,9};
    int *beg = begin(ia);               //指向ia首个元素
    int *last = end(ia);               //指向尾元素的下一位置的指针

使用begin & end 函数可以很容易的写出一个循环并处理数组中的元素。eg: 

    //pbeg 指向arr的首元素， pend指向arr的尾元素的下一位置
    int *pbeg = begin(arr), *pend = end(arr) ;
    while (pbeg != pend && pbeg >= 0){
        pbeg +=1;  /*(or ++pbeg;) */
        }
    
# 指针运算

指向数组元素的指针可以执行运算包括：解引用，递增，比较，与整数相加，两个指针相减等，用在指针和用在迭代器上意义完全一致。

给一个指针加上（减去）某整数值，结果仍是指针。新指针指向的元素与原来的指针相比前进（后退）该整数值个位置：

    constexpr size_t sz= 5;
    int arr[sz] = {1,2,3,4,5};
    int *ip=arr;           //等价于int *ip = &arr[0[
    int *ip2 = ip +4;      // ip2 指向arr的尾元素arr[4];
当给指针加一个整数，得到的新指针仍需指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置，即在数组的范围：

    int *p =arr +sa;           //指向尾元素的下一个位置 ， 不要解引用，不然会出错误，系统发现不了
    int *p2 - arr +10;         //错误：arr 只有5个元素， p2 的值未定义


和迭代器一样，两个指针相加减的结果是他们之间的距离。参与运算的两个指针必须是指向同一个数组当中的元素：

    auto n =end(arr) - begin(arr);    //n 的值是5，也就是arr中元素的数量
 
 两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t 一样，ptrdiff_t 也是一种定义在cstdef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t 是一种带符号类型。
 
 只要两个指针指向同一个数组中的元素，就能用运算关系符对其进行比较：
 
     int *b =arr, *e =arr +sz;
     while (b<e){
            ++b;}
            
如果两个指针分别指向不相关的对象，则不能比较他们。

# 解引用和指针运算的交互

指针加上一个整数所得的结果还是一个指针。假设结果指向了一个元素，则允许解引用该结果指针：

    int ia[] = {0,2,4,6,8};       
    int last = *(ia+4);  //把last 初始化成8，也就是ia[4]的值。 
表达式 *(ia+4) 计算ia 前进4 个元素的新地址,解引用该结果指针的效果等价于表达式ia[4].

表达式含有解引用运算符和点运算符。最好在必要的地方加上圆括号：

    last  = *ia +4; // 正确： last =4 等价于 ia[0] +4
此式的意思是，先解引用ia， 然后在解引用的结果上加4.

# 下标和指针

    int ia = {0,2,4,6,8};        
    int i = ia[2];               //ia 转换成指向数组首元素， ia[2]得到（ia +2) 所指的元素
    int *p =ia;                 // p 指向ia的首元素
    i = *(p+2);                  // 等价于 ia[2]
    int *p = &ia[2];             //p指向索引为2 的元素
    int j = p[1];                 //p[1]等价于 *(p+1),就是ia[3]
    in k =p[-2];                 //p[-2] 是ia[0] 表示的那个元素

# 多维数组

![](https://github.com/linbearababy/primer-c-/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-20%2019.41.54.png)

# 多维数组的初始化

![](https://github.com/linbearababy/primer-c-/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-20%2019.46.14.png)

# 多维数组的下标引用

![](https://github.com/linbearababy/primer-c-/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-20%2019.48.44.png)

![](https://github.com/linbearababy/primer-c-/blob/master/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-05-20%2019.48.52.png)
